local TDS = {}
local Player = {}
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Towers = workspace:WaitForChild("Towers")

Player.Actions = {}
Player.CurrentIndex = 1
Player.Playing = false

function TDS:Place(towerName, x, y, z, isShore, isHidden, wave, time, extra)
    table.insert(Player.Actions, {
        Type = "Place",
        Tower = towerName,
        Position = Vector3.new(x, y, z),
        IsShore = isShore,
        IsHidden = isHidden,
        Wave = wave,
        Time = time,
        Extra = extra
    })
end

function TDS:Upgrade(index, time, upgradeName)
    table.insert(Player.Actions, {
        Type = "Upgrade",
        Index = index,
        Time = time,
        UpgradeName = upgradeName
    })
end

function TDS:Sell(index, time)
    table.insert(Player.Actions, {
        Type = "Sell",
        Index = index,
        Time = time
    })
end

function TDS:Skip(wave, time)
    table.insert(Player.Actions, {
        Type = "Skip",
        Wave = wave,
        Time = time
    })
end

function TDS:WaitWave(wave, min, sec)
    table.insert(Player.Actions, {
        Type = "WaitWave",
        Wave = wave,
        Minute = min,
        Second = sec
    })
end

-- FIXED: TDS:Load now uses shared environment correctly
function TDS:Load(stratString)
    local env = { TDS = TDS }
    local f, err = loadstring(stratString)
    if not f then error("Strat Load Error: " .. err) end
    setfenv(f, env)
    f()
end

local function waitForWave(wave)
    while (ReplicatedStorage.GameStats:GetAttribute("Wave") or 0) < wave do
        task.wait(0.2)
    end
end

local function waitUntil(min, sec)
    local target = min * 60 + sec
    while true do
        local t = ReplicatedStorage.GameStats:GetAttribute("WaveTime")
        if t and t >= target then break end
        task.wait(0.1)
    end
end

local function waitForTimeEntry(t)
    if typeof(t) == "table" then
        waitUntil(t[1], t[2])
    end
end

local function getTowerByIndex(index)
    return Towers:GetChildren()[index]
end

function Player:Play()
    self.Playing = true
    while self.CurrentIndex <= #self.Actions and self.Playing do
        local action = self.Actions[self.CurrentIndex]

        if action.Type == "WaitWave" then
            waitForWave(action.Wave)
            waitUntil(action.Minute, action.Second)

        elseif action.Type == "Place" then
            waitForWave(action.Wave)
            waitForTimeEntry(action.Time)
            ReplicatedStorage.RemoteFunction:InvokeServer("Troops", "Place", action.Tower, action.Position, action.IsShore, action.IsHidden)

        elseif action.Type == "Upgrade" then
            waitForTimeEntry(action.Time)
            local tower = getTowerByIndex(action.Index)
            if tower then
                ReplicatedStorage.RemoteFunction:InvokeServer("Troops", "Upgrade", tower)
            end

        elseif action.Type == "Sell" then
            waitForTimeEntry(action.Time)
            local tower = getTowerByIndex(action.Index)
            if tower then
                ReplicatedStorage.RemoteFunction:InvokeServer("Troops", "Sell", tower)
            end

        elseif action.Type == "Skip" then
            waitForWave(action.Wave)
            waitForTimeEntry(action.Time)
            ReplicatedStorage.RemoteFunction:InvokeServer("Waves", "Skip")
        end

        self.CurrentIndex += 1
        task.wait()
    end
end

function Player:Stop()
    self.Playing = false
end

function Player:Reset()
    self.CurrentIndex = 1
    self.Playing = false
end

-- Export
_G.TDS = TDS
_G.Player = Player
