repeat task.wait() until game:IsLoaded()

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local rF = ReplicatedStorage:WaitForChild("RemoteFunction")
local State = ReplicatedStorage:WaitForChild("State")
local Timer = State:WaitForChild("Timer")
local WaveGui = Players.LocalPlayer:WaitForChild("PlayerGui")
    :WaitForChild("ReactGameTopGameDisplay")
    :WaitForChild("Frame").wave.container:WaitForChild("value")

local function getCurrentTime()
    local wave = tonumber(WaveGui.Text:match("%d+")) or 0
    local t = Timer.Time.Value
    return wave, math.floor(t / 60), math.floor(t % 60)
end

local function waitForWaveTime(wave, min, sec)
    while true do
        local curWave, curMin, curSec = getCurrentTime()
        if curWave > wave or (curWave == wave and (curMin > min or (curMin == min and curSec >= sec))) then
            break
        end
        task.wait()
    end
end

local TDS = {}

function TDS:Place(name, x, y, z, wave, min, sec, useRot, rotX, rotY, rotZ, usePath)
    print(("[DEBUG] Place %s at (%.2f, %.2f, %.2f) on Wave %d, Time %02d:%02d"):format(name, x, y, z, wave, min, sec))
    waitForWaveTime(wave, min, sec)
    local cf = CFrame.new(x, y, z)
    if useRot then
        cf = cf * CFrame.Angles(math.rad(rotX), math.rad(rotY), math.rad(rotZ))
    end
    rF:InvokeServer("Troops", "Place", {
        Position = cf.Position,
        Rotation = cf.Rotation,
        Path = usePath and "Path1" or nil
    }, name)
end

function TDS:Upgrade(id, wave, min, sec)
    print(("[DEBUG] Upgrade Tower #%d at Wave %d, Time %02d:%02d"):format(id, wave, min, sec))
    waitForWaveTime(wave, min, sec)
    local tower = workspace.Towers:GetChildren()[id]
    if tower then
        rF:InvokeServer("Troops", "Upgrade", tower)
    else
        warn("[ERROR] Upgrade failed, tower ID not found:", id)
    end
end

function TDS:Target(id, mode, wave, min, sec)
    print(("[DEBUG] Target Tower #%d to %s at Wave %d, Time %02d:%02d"):format(id, mode, wave, min, sec))
    waitForWaveTime(wave, min, sec)
    local tower = workspace.Towers:GetChildren()[id]
    if tower then
        rF:InvokeServer("Troops", "Set", {Troop = tower, Target = mode})
    else
        warn("[ERROR] Target failed, tower ID not found:", id)
    end
end

function TDS:Ability(id, wave, min, sec)
    print(("[DEBUG] Ability Activate on Tower #%d at Wave %d, Time %02d:%02d"):format(id, wave, min, sec))
    waitForWaveTime(wave, min, sec)
    local tower = workspace.Towers:GetChildren()[id]
    if tower then
        rF:InvokeServer("Troops", "Activate", {Troop = tower})
    else
        warn("[ERROR] Ability failed, tower ID not found:", id)
    end
end

function TDS:Option(id, name, value, wave, min, sec)
    print(("[DEBUG] Option Set Tower #%d -> %s = %s at Wave %d, Time %02d:%02d"):format(id, name, tostring(value), wave, min, sec))
    waitForWaveTime(wave, min, sec)
    local tower = workspace.Towers:GetChildren()[id]
    if tower then
        rF:InvokeServer("Troops", "Option", "Set", {
            Troop = tower,
            Name = name,
            Value = value
        })
    else
        warn("[ERROR] Option failed, tower ID not found:", id)
    end
end

function TDS:Sell(id, wave, min, sec)
    print(("[DEBUG] Sell Tower #%d at Wave %d, Time %02d:%02d"):format(id, wave, min, sec))
    waitForWaveTime(wave, min, sec)
    local tower = workspace.Towers:GetChildren()[id]
    if tower then
        rF:InvokeServer("Troops", "Sell", {Troop = tower})
    else
        warn("[ERROR] Sell failed, tower ID not found:", id)
    end
end

function TDS:VoteSkip(wave, min, sec)
    print(("[DEBUG] VoteSkip at Wave %d, Time %02d:%02d"):format(wave, min, sec))
    waitForWaveTime(wave, min, sec)
    rF:InvokeServer("Voting", "Skip")
end

function TDS:WaitWave(wave, min, sec)
    print(("[DEBUG] WaitWave until Wave %d, Time %02d:%02d"):format(wave, min, sec))
    waitForWaveTime(wave, min, sec)
end

return TDS
